import React, { useState, useRef, useEffect, useCallback } from "react";
import ReactFlow, { addEdge, Controls, Background, useNodesState, useEdgesState } from "reactflow";
import "reactflow/dist/style.css";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const COLORS = {
  FAILED: '#ff0000',
  ISOLATED_LINK: '#ff00ff',
  RESTRICTED: '#00ffff',
  ISOLATED_NODE: '#ffff00',
  MST: '#00ff00',
  NODE: '#888888',
  NEXT_HOP: '#ffffff',
  DEFAULT_EDGE: '#00a8ff'
};

function App() {
  const [state, setState] = useState({
    topology: "",
    algorithm: "IPFRR",
    masses: "",
    selectedFailures: [],
    backupConfigs: [],
    isLoading: false,
    isVisualizing: false,
    error: "",
    unlimitedConfigs: false,
    activeConfig: null,
    stats: null,
    showLegend: false,
    showInSeparateWindow: false,
    showRoutingTables: false,
    routingTablesWindow: null,
    showRoutingTablesInline: false
  });

  const refs = {
    mount: useRef(null),
    scene: useRef(null),
    renderer: useRef(null),
    camera: useRef(null),
    controls: useRef(null),
    visualizationWindow: useRef(null),
    separateWindow: {
      scene: useRef(null),
      renderer: useRef(null),
      camera: useRef(null),
      controls: useRef(null)
    }
  };

  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  const updateState = (updates) => setState(prev => ({ ...prev, ...updates }));
  const getNodeNum = (id) => parseInt(id.replace('node-', ''), 10);
  const isLinkFailed = (source, target) => state.selectedFailures.includes(`${source}-${target}`);

  const openRoutingTablesWindow = () => {
    if (state.routingTablesWindow && !state.routingTablesWindow.closed) {
      state.routingTablesWindow.focus();
      return;
    }

    const width = 800, height = 600;
    const left = (window.screen.width - width) / 2;
    const top = (window.screen.height - height) / 2;

    const newWindow = window.open("", "RoutingTables", 
      `width=${width},height=${height},left=${left},top=${top}`);

    if (!newWindow) {
      alert("Popup was blocked. Please allow popups for this site.");
      return;
    }

    updateState({ routingTablesWindow: newWindow, showRoutingTables: true });

    newWindow.document.write(`
      <!DOCTYPE html>
      <html>
        <head><title>Routing Tables</title></head>
        <body>
          <div id="tables-content" style="padding:20px"></div>
        </body>
      </html>
    `);
    newWindow.document.close();
    updateRoutingTablesWindow(newWindow);

    newWindow.onbeforeunload = () => {
      updateState({ routingTablesWindow: null, showRoutingTables: false });
    };
  };

  const updateRoutingTablesWindow = (windowRef) => {
    if (!windowRef || !state.activeConfig?.next_hop_tables) return;

    const contentDiv = windowRef.document.getElementById('tables-content');
    if (!contentDiv) return;

    contentDiv.innerHTML = `
      <div style="margin-bottom:20px">
        <h2 style="color:#1a237e;border-bottom:1px solid #ddd;padding-bottom:10px">
          Backup Configuration ${state.backupConfigs.findIndex(c => c === state.activeConfig) + 1}
        </h2>
        <div style="display:flex;gap:10px;margin-top:10px">
          <span style="background:${COLORS.ISOLATED_LINK};color:white;padding:4px 8px;border-radius:4px">
            ${state.activeConfig.isolated_links?.length || 0} isolated links
          </span>
          <span style="background:${COLORS.RESTRICTED};color:white;padding:4px 8px;border-radius:4px">
            ${state.activeConfig.restricted_links?.length || 0} restricted links
          </span>
          <span style="background:${COLORS.ISOLATED_NODE};color:black;padding:4px 8px;border-radius:4px">
            ${state.activeConfig.isolated_nodes?.length || 0} isolated nodes
          </span>
        </div>
      </div>
    `;

    Object.entries(state.activeConfig.next_hop_tables).forEach(([nodeId, table]) => {
      const tableContainer = windowRef.document.createElement('div');
      tableContainer.style.background = 'white';
      tableContainer.style.borderRadius = '5px';
      tableContainer.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
      tableContainer.style.padding = '15px';
      tableContainer.style.marginBottom = '20px';
      
      const title = windowRef.document.createElement('div');
      title.style.fontWeight = 'bold';
      title.style.color = '#0d47a1';
      title.style.marginBottom = '5px';
      title.textContent = `Node ${nodeId} Routing Table`;
      tableContainer.appendChild(title);

      const tableEl = windowRef.document.createElement('table');
      tableEl.style.width = '100%';
      tableEl.style.borderCollapse = 'collapse';
      tableEl.style.marginTop = '10px';
      
      const thead = windowRef.document.createElement('thead');
      const headerRow = windowRef.document.createElement('tr');
      ['Destination', 'Next Hop'].forEach(text => {
        const th = windowRef.document.createElement('th');
        th.style.padding = '8px 12px';
        th.style.textAlign = 'left';
        th.style.borderBottom = '1px solid #ddd';
        th.style.backgroundColor = '#f2f2f2';
        th.style.fontWeight = 'bold';
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      tableEl.appendChild(thead);

      const tbody = windowRef.document.createElement('tbody');
      Object.entries(table.next_hops).forEach(([dest, nextHop]) => {
        const row = windowRef.document.createElement('tr');
        row.style.borderBottom = '1px solid #ddd';
        
        const destCell = windowRef.document.createElement('td');
        destCell.style.padding = '8px 12px';
        destCell.textContent = `Node ${dest}`;
        row.appendChild(destCell);
        
        const nextHopCell = windowRef.document.createElement('td');
        nextHopCell.style.padding = '8px 12px';
        nextHopCell.textContent = `Node ${nextHop}`;
        row.appendChild(nextHopCell);
        
        tbody.appendChild(row);
      });
      tableEl.appendChild(tbody);
      tableContainer.appendChild(tableEl);
      contentDiv.appendChild(tableContainer);
    });

    if (contentDiv.children.length === 1) {
      const emptyMsg = windowRef.document.createElement('div');
      emptyMsg.style.color = '#666';
      emptyMsg.style.fontStyle = 'italic';
      emptyMsg.style.textAlign = 'center';
      emptyMsg.style.padding = '20px';
      emptyMsg.textContent = 'No routing tables available in the current configuration.';
      contentDiv.appendChild(emptyMsg);
    }
  };

  const closeRoutingTablesWindow = () => {
    if (state.routingTablesWindow && !state.routingTablesWindow.closed) {
      state.routingTablesWindow.close();
    }
    updateState({ routingTablesWindow: null, showRoutingTables: false });
  };

  const toggleInlineRoutingTables = () => {
    updateState({ showRoutingTablesInline: !state.showRoutingTablesInline });
  };

  const handleChange = (field) => (e) => updateState({ [field]: e.target.value, error: field === 'topology' ? "" : state.error });
  const handleAlgorithmChange = handleChange('algorithm');
  const handleMassesChange = handleChange('masses');
  const handleTopologyChange = handleChange('topology');

  const handleFailureSelection = (e) => {
    const selectedOptions = Array.from(e.target.selectedOptions, option => option.value);
    updateState({ selectedFailures: selectedOptions });

    setEdges(eds => eds.map(edge => {
      const sourceNum = getNodeNum(edge.source);
      const targetNum = getNodeNum(edge.target);
      const failed = isLinkFailed(sourceNum, targetNum);
      
      return {
        ...edge,
        style: { ...edge.style, stroke: failed ? COLORS.FAILED : COLORS.DEFAULT_EDGE, strokeWidth: failed ? 3 : 2 },
        markerEnd: { type: 'arrowclosed', color: failed ? COLORS.FAILED : COLORS.DEFAULT_EDGE }
      };
    }));

    if (refs.scene.current) {
      refs.scene.current.children.forEach(child => {
        if (child.userData.isFailureElement) refs.scene.current.remove(child);
      });

      if (selectedOptions.length && state.topology) {
        try {
          const { nodes } = JSON.parse(state.topology);
          selectedOptions.forEach(failure => {
            const [src, dst] = failure.split('-').map(Number);
            if (src >= 0 && src < nodes.length && dst >= 0 && dst < nodes.length) {
              const points = [
                new THREE.Vector3(nodes[src].x, nodes[src].y, nodes[src].z || 0),
                new THREE.Vector3(nodes[dst].x, nodes[dst].y, nodes[dst].z || 0)
              ];
              const line = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points),
                new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 4 })
              );
              line.userData.isFailureElement = true;
              refs.scene.current.add(line);
            }
          });
        } catch (error) {
          console.error("Error visualizing failures:", error);
        }
      }
    }
  };

  const generateRandomMasses = (numNodes) => 
    Array.from({ length: numNodes }, () => (Math.random() * 10).toFixed(2));

  const computeBackupConfig = async () => {
    if (!state.topology) {
      updateState({ error: "Please enter a valid topology." });
      return;
    }

    updateState({ isLoading: true, error: "", backupConfigs: [], stats: null });

    try {
      const payload = {
        topology: JSON.parse(state.topology),
        algorithm: state.algorithm,
        masses: state.masses ? JSON.parse(state.masses) : generateRandomMasses(nodes.length),
        unlimited_configs: state.unlimitedConfigs,
        failures: {
          links: state.selectedFailures.map(link => link.split('-').map(Number)),
          nodes: []
        }
      };

      const response = await fetch("http://localhost:5000/compute-backup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || `HTTP error! Status: ${response.status}`);
      }

      const result = await response.json();
      updateState({ 
        backupConfigs: result.backup_configs,
        stats: {
          nodeCount: result.node_count,
          edgeCount: result.edge_count,
          failedLinks: result.failed_links,
          message: result.message
        }
      });
    } catch (error) {
      updateState({ error: `Error: ${error.message}` });
      console.error("Backend error:", error);
    } finally {
      updateState({ isLoading: false });
    }
  };

  const downloadFile = (content, fileName, fileType) => {
    const blob = new Blob([content], { type: fileType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(url);
  };

  const downloadAllBackupConfigs = () => {
    try {
      state.backupConfigs.forEach((config, i) => 
        downloadFile(JSON.stringify(config, null, 2), `backup_config_${i}.json`, "application/json")
      );
      alert(`Downloading ${state.backupConfigs.length} configuration files.`);
    } catch (error) {
      updateState({ error: `Failed to prepare download: ${error.message}` });
    }
  };

  const convertToTopology = () => {
    try {
      const topologyData = {
        nodes: nodes.map(node => ({ x: node.position.x, y: node.position.y, z: 0 })),
        links: edges.map(edge => ({
          start: getNodeNum(edge.source),
          end: getNodeNum(edge.target)
        }))
      };
      updateState({ topology: JSON.stringify(topologyData, null, 2), error: "" });
    } catch (error) {
      updateState({ error: `Error: ${error.message}` });
    }
  };

  const addNode = () => setNodes(nds => [...nds, {
    id: `node-${nds.length}`,
    position: { x: Math.random() * 400, y: Math.random() * 400 },
    data: { label: `Node ${nds.length}` }
  }]);

  const onConnect = useCallback(
    (params) => setEdges(eds => {
      const edgeId = `${params.source.replace('node-', '')}-${params.target.replace('node-', '')}`;
      const failed = state.selectedFailures.includes(edgeId);
      return addEdge({
        ...params,
        id: `edge-${eds.length}`,
        label: `L${eds.length}`,
        labelBgPadding: [4, 4],
        labelBgBorderRadius: 4,
        labelBgStyle: { fill: '#fff', fillOpacity: 0.7 },
        style: { strokeWidth: failed ? 3 : 2, stroke: failed ? COLORS.FAILED : COLORS.DEFAULT_EDGE },
        markerEnd: { type: 'arrowclosed', color: failed ? COLORS.FAILED : COLORS.DEFAULT_EDGE }
      }, eds);
    }),
    [state.selectedFailures]
  );

  const importTopology = (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = JSON.parse(e.target.result);
        if (!data.nodes || !data.links) throw new Error("Invalid topology format");

        const importedNodes = data.nodes.map((node, i) => ({
          id: `node-${i}`,
          position: { x: node.x, y: node.y },
          data: { label: `Node ${i}` }
        }));

        const importedEdges = data.links.map((link, i) => {
          const source = `node-${link.start}`;
          const target = `node-${link.end}`;
          const failed = isLinkFailed(link.start, link.end);
          
          return {
            id: `edge-${i}`,
            source,
            target,
            label: `L${i}`,
            labelBgPadding: [4, 4],
            labelBgBorderRadius: 4,
            labelBgStyle: { fill: '#fff', fillOpacity: 0.7 },
            style: { strokeWidth: failed ? 3 : 2, stroke: failed ? COLORS.FAILED : COLORS.DEFAULT_EDGE },
            markerEnd: { type: 'arrowclosed', color: failed ? COLORS.FAILED : COLORS.DEFAULT_EDGE }
          };
        });

        setNodes(importedNodes);
        setEdges(importedEdges);
        updateState({ topology: JSON.stringify(data, null, 2), error: "" });
      } catch (error) {
        updateState({ error: `Error: ${error.message}` });
      }
    };
    reader.onerror = () => updateState({ error: "Failed to read the file." });
    reader.readAsText(file);
  };

  const createLinkLabel = (index, color = '#ffffff') => {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = color;
    ctx.font = 'Bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`L${index}`, canvas.width/2, canvas.height/2);
    return new THREE.CanvasTexture(canvas);
  };

  const visualizeElement = (scene, config, type) => {
    if (!scene || !state.topology) return;

    try {
      const { nodes, links } = JSON.parse(state.topology);
      if (!nodes?.length) return;

      const validateNodeIndex = (index) => index >= 0 && index < nodes.length;

      nodes.forEach((node, i) => {
        const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 16, 16),
          new THREE.MeshStandardMaterial({ color: 0x888888 })
        );
        sphere.position.set(node.x, node.y, node.z || 0);
        sphere.userData.isBackupElement = true;
        scene.add(sphere);
      });

      config.isolated_links?.forEach(([src, dst]) => {
        if (!validateNodeIndex(src) || !validateNodeIndex(dst)) return;
        visualizeLink(scene, nodes, links, src, dst, COLORS.ISOLATED_LINK);
      });

      config.restricted_links?.forEach(([src, dst]) => {
        if (!validateNodeIndex(src) || !validateNodeIndex(dst)) return;
        visualizeLink(scene, nodes, links, src, dst, COLORS.RESTRICTED, true);
      });

      if (config.next_hop_tables) {
        Object.entries(config.next_hop_tables).forEach(([nodeId, table]) => {
          const nodeIdx = parseInt(nodeId);
          if (!validateNodeIndex(nodeIdx)) return;
          
          const node = nodes[nodeIdx];
          Object.entries(table.next_hops).forEach(([dest, nextHop]) => {
            const destIdx = parseInt(dest);
            const nextHopIdx = parseInt(nextHop);
            
            if (validateNodeIndex(destIdx) && validateNodeIndex(nextHopIdx)) {
              const nextHopNode = nodes[nextHopIdx];
              const start = new THREE.Vector3(node.x, node.y, (node.z || 0) + 0.2);
              const end = new THREE.Vector3(
                nextHopNode.x * 0.2 + node.x * 0.8,
                nextHopNode.y * 0.2 + node.y * 0.8,
                (nextHopNode.z || 0) * 0.2 + (node.z || 0) * 0.8 + 0.2
              );
              
              const dir = new THREE.Vector3().subVectors(end, start).normalize();
              const arrow = new THREE.ArrowHelper(dir, start, 0.3, 0xffffff, 0.1, 0.05);
              arrow.userData.isBackupElement = true;
              scene.add(arrow);
            }
          });
        });
      }

      config.isolated_nodes?.forEach(nodeIdx => {
        if (!validateNodeIndex(nodeIdx)) return;
        const node = nodes[nodeIdx];
        const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(0.25, 32, 32),
          new THREE.MeshStandardMaterial({ 
            color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 
          })
        );
        sphere.position.set(node.x, node.y, (node.z || 0) + 0.1);
        sphere.userData.isBackupElement = true;
        scene.add(sphere);
      });

      config.mst_edges?.forEach(([src, dst]) => {
        if (!validateNodeIndex(src) || !validateNodeIndex(dst)) return;
        visualizeLink(scene, nodes, links, src, dst, COLORS.MST);
      });

    } catch (error) {
      console.error(`Error visualizing ${type}:`, error);
      updateState({ error: `Visualization error: ${error.message}` });
    }
  };

  const visualizeLink = (scene, nodes, links, src, dst, color, dashed = false) => {
    const points = [
      new THREE.Vector3(nodes[src].x, nodes[src].y, nodes[src].z || 0),
      new THREE.Vector3(nodes[dst].x, nodes[dst].y, nodes[dst].z || 0)
    ];
    
    const material = dashed 
      ? new THREE.LineDashedMaterial({ color, dashSize: 0.3, gapSize: 0.2, linewidth: 4 })
      : new THREE.LineBasicMaterial({ color, linewidth: 4 });
    
    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
    if (dashed) line.computeLineDistances();
    line.userData.isBackupElement = true;
    scene.add(line);

    const linkIndex = links.findIndex(l => 
      (l.start === src && l.end === dst) || (l.start === dst && l.end === src)
    );
    if (linkIndex !== -1) {
      const midpoint = new THREE.Vector3().lerpVectors(points[0], points[1], 0.5);
      const label = new THREE.Sprite(
        new THREE.SpriteMaterial({ map: createLinkLabel(linkIndex, color) })
      );
      label.position.copy(midpoint);
      label.scale.set(0.5, 0.25, 1);
      label.userData.isBackupElement = true;
      scene.add(label);
    }

    if (dashed) {
      const dir = new THREE.Vector3().subVectors(points[1], points[0]).normalize();
      scene.add(new THREE.ArrowHelper(dir, points[0], 0.5, color, 0.3, 0.2));
      scene.add(new THREE.ArrowHelper(dir.clone().negate(), points[1], 0.5, color, 0.3, 0.2));
    }
  };

  const visualizeBackupConfig = async (config) => {
    updateState({ 
      isVisualizing: true, 
      activeConfig: config,
      showRoutingTablesInline: false
    });
    
    if (!refs.scene.current) {
      console.error("Scene not ready");
      updateState({ isVisualizing: false });
      return;
    }
    
    refs.scene.current.children.forEach(child => {
      if (child.userData.isBackupElement && !child.userData.isFailureElement) {
        refs.scene.current.remove(child);
      }
      if (child.userData.isBaseElement) child.visible = false;
    });
    
    await new Promise(resolve => setTimeout(resolve, 50));
    visualizeElement(refs.scene.current, config, "backup config");
    
    if (state.showRoutingTables && state.routingTablesWindow) {
      updateRoutingTablesWindow(state.routingTablesWindow);
    }
    
    updateState({ isVisualizing: false });
  };

  const clearVisualization = () => {
    updateState({ 
      activeConfig: null, 
      isVisualizing: false,
      showRoutingTablesInline: false
    });
    if (refs.scene.current) {
      const toRemove = [];
      refs.scene.current.children.forEach(child => {
        if (child.userData.isBackupElement || child.userData.isFailureElement) {
          toRemove.push(child);
        }
        if (child.userData.isBaseElement) child.visible = true;
      });
      
      toRemove.forEach(child => {
        refs.scene.current.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(m => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      
      if (refs.renderer.current && refs.camera.current) {
        refs.renderer.current.render(refs.scene.current, refs.camera.current);
      }
    }
    closeRoutingTablesWindow();
  };

  const openVisualizationInNewWindow = () => {
    if (refs.visualizationWindow.current && !refs.visualizationWindow.current.closed) {
      refs.visualizationWindow.current.focus();
      return;
    }

    const width = 800, height = 600;
    const left = (window.screen.width - width) / 2;
    const top = (window.screen.height - height) / 2;

    const newWindow = window.open("", "3DVisualization", 
      `width=${width},height=${height},left=${left},top=${top}`);

    if (!newWindow) {
      alert("Popup was blocked. Please allow popups for this site.");
      return;
    }

    refs.visualizationWindow.current = newWindow;
    newWindow.document.write(`
      <!DOCTYPE html>
      <html>
        <head><title>3D Network Visualization</title>
          <style>
            body { margin: 0; overflow: hidden; background-color: #000; }
            #container { width: 100%; height: 100vh; }
            .legend {
              position: absolute; bottom: 10px; left: 10px;
              background: rgba(0,0,0,0.7); color: white; padding: 10px;
              border-radius: 5px; font-family: Arial, sans-serif; font-size: 12px;
              border: 1px solid #333;
            }
            .legend-item { display: flex; align-items: center; margin: 5px 0; }
            .legend-color { width: 20px; height: 20px; margin-right: 8px; border-radius: 3px; }
          </style>
        </head>
        <body>
          <div id="container"></div>
          <div class="legend">
            <h4 style="margin-top: 0; margin-bottom: 10px; color: #fff;">Legend</h4>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.FAILED};"></div>Failed Links</div>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.ISOLATED_LINK};"></div>Isolated Links</div>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.RESTRICTED};"></div>Restricted Links</div>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.ISOLATED_NODE};"></div>Isolated Nodes</div>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.MST};"></div>MST Edges</div>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.NODE};"></div>All Nodes</div>
            <div class="legend-item"><div class="legend-color" style="background: ${COLORS.NEXT_HOP}; border: 1px solid #000;"></div>Next Hop Indicators</div>
          </div>
        </body>
      </html>
    `);
    newWindow.document.close();

    const container = newWindow.document.getElementById('container');
    const scene = new THREE.Scene();
    refs.separateWindow.scene.current = scene;
    
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    refs.separateWindow.camera.current = camera;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    refs.separateWindow.renderer.current = renderer;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    refs.separateWindow.controls.current = controls;

    scene.add(new THREE.AmbientLight(0x404040, 0.5));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    if (state.topology) {
      try {
        const data = JSON.parse(state.topology);
        if (!data.nodes || !data.links) throw new Error("Invalid topology data");
        const nodes = data.nodes.map(node => ({ ...node, z: node.z || 0 }));
        const links = data.links;

        const degreeMap = new Map();
        links.forEach(link => {
          degreeMap.set(link.start, (degreeMap.get(link.start) || 0) + 1);
          degreeMap.set(link.end, (degreeMap.get(link.end) || 0) + 1);
        });

        nodes.forEach((node, i) => {
          const degree = degreeMap.get(i) || 0;
          const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 16, 16),
            new THREE.MeshStandardMaterial({ color: degree === 2 ? 0x00ff00 : 0xff0000 })
          );
          sphere.position.set(node.x, node.y, node.z);
          sphere.userData.isBaseElement = true;
          scene.add(sphere);
        });

        links.forEach((link, i) => {
          const start = nodes[link.start];
          const end = nodes[link.end];
          
          const line = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([
              new THREE.Vector3(start.x, start.y, start.z),
              new THREE.Vector3(end.x, end.y, end.z)
            ]),
            new THREE.LineBasicMaterial({ color: 0x00a8ff, linewidth: 2 })
          );
          line.userData.isBaseElement = true;
          scene.add(line);

          const midpoint = new THREE.Vector3(
            (start.x + end.x) / 2,
            (start.y + end.y) / 2,
            (start.z + end.z) / 2 + 0.1
          );

          const label = new THREE.Sprite(
            new THREE.SpriteMaterial({ map: createLinkLabel(i) })
          );
          label.position.copy(midpoint);
          label.scale.set(0.5, 0.25, 1);
          label.userData.isBaseElement = true;
          scene.add(label);
        });

        const bbox = new THREE.Box3().setFromObject(scene);
        const center = bbox.getCenter(new THREE.Vector3());
        const size = bbox.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        camera.position.set(center.x, center.y, center.z + maxDim / Math.tan(fov / 2));
        camera.lookAt(center);

        state.selectedFailures.forEach(failure => {
          const [src, dst] = failure.split('-').map(Number);
          if (src >= 0 && src < nodes.length && dst >= 0 && dst < nodes.length) {
            const line = new THREE.Line(
              new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(nodes[src].x, nodes[src].y, nodes[src].z || 0),
                new THREE.Vector3(nodes[dst].x, nodes[dst].y, nodes[dst].z || 0)
              ]),
              new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 4 })
            );
            line.userData.isFailureElement = true;
            scene.add(line);
          }
        });

        if (state.activeConfig) {
          visualizeElement(scene, state.activeConfig, "backup config in separate window");
        }

        const animate = () => {
          if (newWindow.closed) return;
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        };
        animate();

        newWindow.onbeforeunload = () => {
          refs.visualizationWindow.current = null;
          Object.values(refs.separateWindow).forEach(ref => ref.current = null);
        };
      } catch (error) {
        newWindow.document.write(`<div style="padding: 20px; color: red;">Error: ${error.message}</div>`);
      }
    }
  };

  useEffect(() => {
    if (!state.topology) return;

    try {
      const data = JSON.parse(state.topology);
      if (!data.nodes || !data.links) throw new Error("Invalid topology data");
      const nodes = data.nodes.map(node => ({ ...node, z: node.z || 0 }));
      const links = data.links;

      if (refs.mount.current.children.length > 0) {
        refs.mount.current.removeChild(refs.mount.current.children[0]);
      }

      const scene = new THREE.Scene();
      refs.scene.current = scene;
      
      const camera = new THREE.PerspectiveCamera(
        75,
        refs.mount.current.clientWidth / refs.mount.current.clientHeight,
        0.1,
        1000
      );
      refs.camera.current = camera;
      
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(refs.mount.current.clientWidth, refs.mount.current.clientHeight);
      refs.renderer.current = renderer;
      refs.mount.current.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      refs.controls.current = controls;

      scene.add(new THREE.AmbientLight(0x404040, 0.5));
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      const degreeMap = new Map();
      links.forEach(link => {
        degreeMap.set(link.start, (degreeMap.get(link.start) || 0) + 1);
        degreeMap.set(link.end, (degreeMap.get(link.end) || 0) + 1);
      });

      nodes.forEach((node, i) => {
        const degree = degreeMap.get(i) || 0;
        const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 16, 16),
          new THREE.MeshStandardMaterial({ color: degree === 2 ? 0x00ff00 : 0xff0000 })
        );
        sphere.position.set(node.x, node.y, node.z);
        sphere.userData.isBaseElement = true;
        scene.add(sphere);
      });

      links.forEach((link, i) => {
        const start = nodes[link.start];
        const end = nodes[link.end];
        
        const line = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(start.x, start.y, start.z),
            new THREE.Vector3(end.x, end.y, end.z)
          ]),
          new THREE.LineBasicMaterial({ color: 0x00a8ff, linewidth: 2 })
        );
        line.userData.isBaseElement = true;
        scene.add(line);

        const midpoint = new THREE.Vector3(
          (start.x + end.x) / 2,
          (start.y + end.y) / 2,
          (start.z + end.z) / 2 + 0.1
        );
        const label = new THREE.Sprite(
          new THREE.SpriteMaterial({ map: createLinkLabel(i) })
        );
        label.position.copy(midpoint);
        label.scale.set(0.5, 0.25, 1);
        label.userData.isBaseElement = true;
        scene.add(label);
      });

      const bbox = new THREE.Box3().setFromObject(scene);
      const center = bbox.getCenter(new THREE.Vector3());
      const size = bbox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      camera.position.set(center.x, center.y, center.z + maxDim / Math.tan(fov / 2));
      camera.lookAt(center);

      const animate = () => {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };
      animate();

      if (state.activeConfig) {
        setTimeout(() => visualizeBackupConfig(state.activeConfig), 100);
      }

      if (state.selectedFailures.length > 0) {
        state.selectedFailures.forEach(failure => {
          const [src, dst] = failure.split('-').map(Number);
          if (src >= 0 && src < nodes.length && dst >= 0 && dst < nodes.length) {
            const line = new THREE.Line(
              new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(nodes[src].x, nodes[src].y, nodes[src].z || 0),
                new THREE.Vector3(nodes[dst].x, nodes[dst].y, nodes[dst].z || 0)
              ]),
              new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 4 })
            );
            line.userData.isFailureElement = true;
            scene.add(line);
          }
        });
      }

      return () => {
        if (refs.mount.current && renderer.domElement) {
          refs.mount.current.removeChild(renderer.domElement);
        }
      };
    } catch (error) {
      updateState({ error: `Invalid topology: ${error.message}` });
    }
  }, [state.topology]);

  useEffect(() => {
    if (state.showInSeparateWindow) {
      openVisualizationInNewWindow();
    } else if (refs.visualizationWindow.current && !refs.visualizationWindow.current.closed) {
      refs.visualizationWindow.current.close();
    }
  }, [state.showInSeparateWindow]);

  useEffect(() => {
    if (state.activeConfig && refs.visualizationWindow.current && !refs.visualizationWindow.current.closed) {
      visualizeElement(
        refs.separateWindow.scene.current, 
        state.activeConfig, 
        "backup config in separate window"
      );
    }
  }, [state.activeConfig]);

  const renderRoutingTables = () => {
    if (!state.activeConfig?.next_hop_tables) {
      return (
        <div style={{
          color: '#9e9e9e',
          textAlign: 'center',
          padding: '1rem',
          fontStyle: 'italic'
        }}>
          No routing tables available for this configuration
        </div>
      );
    }

    return (
      <div style={{
        marginTop: '1rem',
        maxHeight: '400px',
        overflowY: 'auto',
        background: '#1e1e1e',
        padding: '1rem',
        borderRadius: '4px'
      }}>
        <div style={{
          marginBottom: '1rem',
          paddingBottom: '1rem',
          borderBottom: '1px solid #333'
        }}>
          <h3 style={{
            margin: '0 0 0.5rem 0',
            color: '#64b5f6'
          }}>
            Backup Configuration {state.backupConfigs.findIndex(c => c === state.activeConfig) + 1}
          </h3>
          <div style={{
            display: 'flex',
            gap: '0.5rem'
          }}>
            <span style={{
              background: COLORS.ISOLATED_LINK,
              color: 'white',
              padding: '0.2rem 0.4rem',
              borderRadius: '3px',
              fontSize: '0.7rem'
            }}>
              {state.activeConfig.isolated_links?.length || 0} isolated links
            </span>
            <span style={{
              background: COLORS.RESTRICTED,
              color: 'white',
              padding: '0.2rem 0.4rem',
              borderRadius: '3px',
              fontSize: '0.7rem'
            }}>
              {state.activeConfig.restricted_links?.length || 0} restricted links
            </span>
            <span style={{
              background: COLORS.ISOLATED_NODE,
              color: 'black',
              padding: '0.2rem 0.4rem',
              borderRadius: '3px',
              fontSize: '0.7rem'
            }}>
              {state.activeConfig.isolated_nodes?.length || 0} isolated nodes
            </span>
          </div>
        </div>
        
        {Object.entries(state.activeConfig.next_hop_tables).map(([nodeId, table]) => (
          <div key={nodeId} style={{
            background: '#252525',
            borderRadius: '4px',
            padding: '1rem',
            marginBottom: '1rem',
            border: '1px solid #333'
          }}>
            <div style={{
              color: '#bbdefb',
              marginBottom: '0.5rem',
              fontWeight: '500'
            }}>
              Node {nodeId} Routing Table
            </div>
            <table style={{
              width: '100%',
              borderCollapse: 'collapse'
            }}>
              <thead>
                <tr>
                  <th style={{
                    padding: '0.5rem',
                    textAlign: 'left',
                    borderBottom: '1px solid #333',
                    background: '#1a237e',
                    color: 'white'
                  }}>Destination</th>
                  <th style={{
                    padding: '0.5rem',
                    textAlign: 'left',
                    borderBottom: '1px solid #333',
                    background: '#1a237e',
                    color: 'white'
                  }}>Next Hop</th>
                </tr>
              </thead>
              <tbody>
                {Object.entries(table.next_hops).map(([dest, nextHop]) => (
                  <tr key={dest} style={{
                    borderBottom: '1px solid #333'
                  }}>
                    <td style={{
                      padding: '0.5rem',
                      textAlign: 'left',
                      borderBottom: '1px solid #333'
                    }}>Node {dest}</td>
                    <td style={{
                      padding: '0.5rem',
                      textAlign: 'left',
                      borderBottom: '1px solid #333'
                    }}>Node {nextHop}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ))}
      </div>
    );
  };

  return (
    <div className="app-container">
      <header className="app-header">
        <div className="container">
          <h1 className="app-title">Network Resilience Visualizer</h1>
          <p className="app-subtitle">IP Fast Re-route with Backup Configurations</p>
        </div>
      </header>

      <main className="container main-content">
        <div className="app-layout">
          <div className="config-panel">
            <div className="panel-card">
              <div className="panel-header">
                <h2>Topology Editor</h2>
                <button 
                  className="legend-toggle"
                  onClick={() => updateState({ showLegend: !state.showLegend })}
                >
                  <i className="icon-info"></i> Legend
                </button>
              </div>
              
              {state.showLegend && (
                <div className="legend-container">
                  <div className="legend-grid">
                    <div><span className="badge failed"></span> Failed Links</div>
                    <div><span className="badge isolated-link"></span> Isolated Links</div>
                    <div><span className="badge restricted"></span> Restricted Links</div>
                    <div><span className="badge isolated-node"></span> Isolated Nodes</div>
                    <div><span className="badge mst"></span> MST Edges</div>
                    <div><span className="badge node"></span> All Nodes</div>
                    <div><span className="badge next-hop"></span> Next Hop Indicators</div>
                  </div>
                </div>
              )}
              
              <div className="flow-container">
                <ReactFlow
                  nodes={nodes}
                  edges={edges}
                  onNodesChange={onNodesChange}
                  onEdgesChange={onEdgesChange}
                  onConnect={onConnect}
                  defaultEdgeOptions={{
                    type: 'default',
                    label: ({ data }) => data.label,
                    labelStyle: { fontSize: 12, fontWeight: 'bold' },
                    labelShowBg: true,
                    labelBgPadding: [4, 4],
                    labelBgBorderRadius: 4,
                    labelBgStyle: { fill: '#fff', fillOpacity: 0.7 },
                    style: { strokeWidth: 2, stroke: COLORS.DEFAULT_EDGE },
                    markerEnd: { type: 'arrowclosed', color: COLORS.DEFAULT_EDGE }
                  }}
                >
                  <Controls style={{ backgroundColor: 'rgba(0, 0, 0, 0.7)' }} />
                  <Background color="#1a1a1a" gap={20} />
                </ReactFlow>
              </div>
              
              <div className="panel-actions">
                <button className="btn primary" onClick={addNode}>
                  <i className="icon-plus"></i> Add Node
                </button>
                <button className="btn secondary" onClick={convertToTopology}>
                  <i className="icon-export"></i> Export Topology
                </button>
              </div>
              
              <div className="import-section">
                <label htmlFor="topologyImport" className="input-label">Import Topology</label>
                <input
                  type="file"
                  id="topologyImport"
                  accept=".json"
                  onChange={importTopology}
                  className="file-input"
                />
              </div>
            </div>

            <div className="panel-card">
              <div className="panel-header">
                <h2>Configuration</h2>
              </div>
              
              <div className="form-group">
                <label className="form-label">Algorithm</label>
                <select className="form-select" value={state.algorithm} onChange={handleAlgorithmChange}>
                  <option value="IPFRR">IP Fast Re-route (IPFRR)</option>
                </select>
              </div>

              <div className="form-group">
                <label className="form-label">Node Masses (Traffic Weights)</label>
                <textarea
                  className="form-textarea"
                  placeholder='Enter node masses as JSON array (e.g., [1.0, 2.0, 3.0])'
                  rows={3}
                  value={state.masses}
                  onChange={handleMassesChange}
                />
                <small className="form-hint">Leave empty for random weights</small>
              </div>

              <div className="form-group">
                <label className="form-label">Failed Links</label>
                <select 
                  multiple 
                  className="form-multiselect" 
                  value={state.selectedFailures}
                  onChange={handleFailureSelection}
                >
                  {edges.map((edge, i) => (
                    <option 
                      key={i} 
                      value={`${edge.source.replace('node-', '')}-${edge.target.replace('node-', '')}`}
                    >
                      Link {i}: Node {edge.source.replace('node-', '')} ↔ Node {edge.target.replace('node-', '')}
                    </option>
                  ))}
                </select>
                <small className="form-hint">Hold Ctrl/Cmd to select multiple links</small>
              </div>

              <div className="form-switch">
                <input
                  type="checkbox"
                  id="unlimitedConfigs"
                  checked={state.unlimitedConfigs}
                  onChange={() => updateState({ unlimitedConfigs: !state.unlimitedConfigs })}
                />
                <label htmlFor="unlimitedConfigs">
                  Generate unlimited backup configurations
                </label>
              </div>

              <button
                className="btn compute-btn"
                onClick={computeBackupConfig}
                disabled={state.isLoading}
              >
                {state.isLoading ? (
                  <>
                    <span className="spinner"></span>
                    Computing...
                  </>
                ) : (
                  "Compute Backup Configurations"
                )}
              </button>

              {state.error && (
                <div className="alert error">
                  <i className="icon-warning"></i>
                  {state.error}
                </div>
              )}
            </div>

            {state.backupConfigs.length > 0 && (
              <div className="panel-card">
                <div className="panel-header">
                  <h2>Backup Configurations</h2>
                  <div className="panel-actions">
                    <button 
                      className="btn icon-btn"
                      onClick={downloadAllBackupConfigs}
                      title="Download all configurations"
                    >
                      <i className="icon-download-all"></i>
                    </button>
                    <button 
                      className="btn icon-btn"
                      onClick={() => state.showRoutingTables ? closeRoutingTablesWindow() : openRoutingTablesWindow()}
                      disabled={!state.activeConfig}
                      title={state.showRoutingTables ? "Close routing tables window" : "Open routing tables in separate window"}
                    >
                      <i className="icon-external"></i>
                    </button>
                    <button 
                      className="btn icon-btn"
                      onClick={clearVisualization}
                      disabled={!state.activeConfig}
                      title="Clear visualization"
                    >
                      <i className="icon-clear"></i>
                    </button>
                  </div>
                </div>
                
                {state.stats && (
                  <div className="stats-container">
                    <div className="stats-message">
                      <i className="icon-info"></i>
                      {state.stats.message}
                    </div>
                    <div className="stats-badges">
                      <span className="badge">Nodes: {state.stats.nodeCount}</span>
                      <span className="badge">Edges: {state.stats.edgeCount}</span>
                      {state.stats.failedLinks?.length > 0 && (
                        <span className="badge failed">Failed Links: {state.stats.failedLinks.length}</span>
                      )}
                    </div>
                  </div>
                )}
                
                <div className="config-list">
                  {state.backupConfigs.map((config, i) => (
                    <div key={i} className="config-item">
                      <button
                        className={`config-btn ${state.activeConfig === config ? 'active' : ''}`}
                        onClick={() => visualizeBackupConfig(config)}
                        disabled={state.isVisualizing}
                        title="Click to visualize"
                      >
                        <span className="config-name">Config {i + 1}</span>
                        <div className="config-stats">
                          <span className="badge isolated-link">{config.isolated_links?.length || 0} isolated</span>
                          <span className="badge restricted">{config.restricted_links?.length || 0} restricted</span>
                          <span className="badge isolated-node">{config.isolated_nodes?.length || 0} nodes</span>
                        </div>
                      </button>
                      <button
                        className="btn icon-btn download-btn"
                        onClick={(e) => {
                          e.stopPropagation();
                          downloadFile(
                            JSON.stringify(config, null, 2),
                            `backup_config_${i}.json`,
                            "application/json"
                          );
                        }}
                        title="Download this configuration"
                      >
                        <i className="icon-download"></i>
                      </button>
                    </div>
                  ))}
                </div>

                {state.activeConfig && (
                  <div style={{
                    padding: '1rem',
                    borderTop: '1px solid #333',
                    background: '#252525'
                  }}>
                    <div style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      marginBottom: '0.5rem'
                    }}>
                      <h3 style={{
                        margin: '0',
                        fontSize: '1.1rem',
                        color: '#e0e0e0'
                      }}>Routing Tables</h3>
                      <button 
                        style={{
                          padding: '0.4rem 0.8rem',
                          borderRadius: '6px',
                          border: 'none',
                          fontWeight: '500',
                          cursor: 'pointer',
                          display: 'inline-flex',
                          alignItems: 'center',
                          gap: '0.5rem',
                          transition: 'all 0.2s',
                          backgroundColor: '#1a237e',
                          color: 'white'
                        }}
                        onClick={toggleInlineRoutingTables}
                      >
                        {state.showRoutingTablesInline ? 'Hide Tables' : 'Show Tables'}
                      </button>
                    </div>
                    {state.showRoutingTablesInline && renderRoutingTables()}
                  </div>
                )}
              </div>
            )}
          </div>

          <div className="visualization-panel">
            <div className="panel-card">
              <div className="panel-header">
                <h2>3D Network Visualization</h2>
                <div className="form-switch">
                  <input
                    type="checkbox"
                    id="separateWindowToggle"
                    checked={state.showInSeparateWindow}
                    onChange={() => updateState({ showInSeparateWindow: !state.showInSeparateWindow })}
                  />
                  <label htmlFor="separateWindowToggle">
                    Show in separate window
                  </label>
                </div>
              </div>
              
              <div className="visualization-container">
                {state.isVisualizing && (
                  <div className="loading-overlay">
                    <div className="spinner"></div>
                  </div>
                )}
                
                {!state.showInSeparateWindow ? (
                  <>
                    <div ref={refs.mount} className="three-container"></div>
                    {state.activeConfig && (
                      <div className="visualization-legend">
                        <div className="legend-content">
                          <strong>Backup Configuration View:</strong> 
                          <div className="legend-badges">
                            <span className="badge failed">Failed Links</span>
                            <span className="badge isolated-link">Isolated Links</span>
                            <span className="badge restricted">Restricted Links</span>
                            <span className="badge isolated-node">Isolated Nodes</span>
                            <span className="badge mst">MST Edges</span>
                            <span className="badge node">All Nodes</span>
                            <span className="badge next-hop">Next Hop Indicators</span>
                          </div>
                        </div>
                      </div>
                    )}
                  </>
                ) : (
                  <div className="separate-window-message">
                    <i className="icon-external"></i>
                    Visualization is shown in a separate window
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </main>

      <style jsx>{`
        .app-container { display: flex; flex-direction: column; min-height: 100vh; background-color: #121212; color: #e0e0e0; }
        .app-header { background: linear-gradient(135deg, #1a237e, #0d47a1); color: white; padding: 2rem 0; margin-bottom: 2rem; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); }
        .app-title { font-size: 2.5rem; font-weight: 700; margin-bottom: 0.5rem; color: white; }
        .app-subtitle { font-size: 1.1rem; opacity: 0.9; color: #bbdefb; }
        .main-content { flex: 1; padding-bottom: 2rem; }
        .app-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .panel-card { background: #1e1e1e; border-radius: 8px; box-shadow: 0 2px 15px rgba(0, 0, 0, 0.3); margin-bottom: 1.5rem; overflow: hidden; border: 1px solid #333; }
        .panel-header { padding: 1rem 1.5rem; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; background: #252525; }
        .panel-header h2 { font-size: 1.3rem; margin: 0; color: #e0e0e0; }
        .legend-toggle { background: none; border: none; color: #64b5f6; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; }
        .legend-container { padding: 1rem 1.5rem; background: #252525; border-bottom: 1px solid #333; }
        .legend-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.8rem; font-size: 0.9rem; color: #e0e0e0; }
        .badge { display: inline-block; width: 12px; height: 12px; border-radius: 2px; margin-right: 0.5rem; }
        .badge.failed { background-color: ${COLORS.FAILED}; }
        .badge.isolated-link { background-color: ${COLORS.ISOLATED_LINK}; }
        .badge.restricted { background-color: ${COLORS.RESTRICTED}; }
        .badge.isolated-node { background-color: ${COLORS.ISOLATED_NODE}; }
        .badge.mst { background-color: ${COLORS.MST}; }
        .badge.node { background-color: ${COLORS.NODE}; }
        .badge.next-hop { background-color: ${COLORS.NEXT_HOP}; border: 1px solid #888; }
        .flow-container { height: 400px; width: 100%; position: relative; }
        .panel-actions { display: flex; gap: 0.8rem; padding: 1rem 1.5rem; border-top: 1px solid #333; background: #252525; }
        .btn { padding: 0.6rem 1.2rem; border-radius: 6px; border: none; font-weight: 500; cursor: pointer; display: inline-flex; align-items: center; gap: 0.5rem; transition: all 0.2s; }
        .btn.primary { background-color: #1a237e; color: white; }
        .btn.primary:hover { background-color: #0d47a1; }
        .btn.secondary { background-color: #333; color: #e0e0e0; }
        .btn.secondary:hover { background-color: #444; }
        .icon-btn { padding: 0.5rem; border-radius: 50%; width: 32px; height: 32px; display: inline-flex; align-items: center; justify-content: center; background-color: #333; color: #e0e0e0; }
        .icon-btn:hover { background-color: #444; }
        .import-section { padding: 0 1.5rem 1.5rem; background: #252525; }
        .input-label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: #e0e0e0; }
        .file-input { width: 100%; padding: 0.5rem; border: 1px solid #444; border-radius: 4px; background: #333; color: #e0e0e0; }
        .form-group { padding: 0 1.5rem; margin-bottom: 1.2rem; }
        .form-label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: #e0e0e0; }
        .form-select, .form-multiselect, .form-textarea { width: 100%; padding: 0.6rem; border: 1px solid #444; border-radius: 4px; background-color: #333; color: #e0e0e0; }
        .form-multiselect { min-height: 100px; }
        .form-textarea { resize: vertical; min-height: 80px; }
        .form-hint { display: block; margin-top: 0.3rem; font-size: 0.8rem; color: #9e9e9e; }
        .form-switch { display: flex; align-items: center; gap: 0.8rem; padding: 0 1.5rem; margin-bottom: 1.2rem; color: #e0e0e0; }
        .form-switch input { position: relative; width: 42px; height: 22px; appearance: none; background: #555; border-radius: 11px; transition: background 0.2s; cursor: pointer; }
        .form-switch input:checked { background: #1a237e; }
        .form-switch input:before { content: ''; position: absolute; width: 18px; height: 18px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: transform 0.2s; }
        .form-switch input:checked:before { transform: translateX(20px); }
        .compute-btn { width: calc(100% - 3rem); margin: 0 1.5rem 1.5rem; padding: 0.8rem; font-size: 1rem; justify-content: center; background-color: #1a237e; color: white; }
        .compute-btn:hover { background-color: #0d47a1; }
        .compute-btn:disabled { background-color: #333; cursor: not-allowed; }
        .spinner { width: 18px; height: 18px; border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: white; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .alert { padding: 0.8rem 1.2rem; border-radius: 4px; margin: 0 1.5rem 1.5rem; display: flex; align-items: center; gap: 0.8rem; }
        .alert.error { background-color: #330000; color: #ff6e6e; border: 1px solid #ff0000; }
        .stats-container { padding: 1rem 1.5rem; border-bottom: 1px solid #333; background: #252525; }
        .stats-message { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; color: #bbdefb; }
        .stats-badges { display: flex; gap: 0.5rem; flex-wrap: wrap; }
        .stats-badges .badge { padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.8rem; background-color: #1a237e; color: white; }
        .stats-badges .badge.failed { background-color: ${COLORS.FAILED}; }
        .config-list { padding: 0.5rem; }
        .config-item { display: flex; margin-bottom: 0.5rem; }
        .config-btn { flex: 1; text-align: left; padding: 0.8rem 1rem; border: 1px solid #444; border-radius: 4px; background: #333; color: #e0e0e0; cursor: pointer; transition: all 0.2s; }
        .config-btn:hover { background-color: #444; }
        .config-btn.active { background-color: #0d47a1; border-color: #1a237e; }
        .config-name { font-weight: 500; margin-right: 1rem; }
        .config-stats { display: flex; gap: 0.5rem; margin-top: 0.3rem; }
        .config-stats .badge { padding: 0.2rem 0.4rem; font-size: 0.7rem; border-radius: 3px; color: black; }
        .download-btn { margin-left: 0.5rem; }
        .visualization-container { position: relative; height: calc(100vh - 200px); min-height: 500px; }
        .three-container { width: 100%; height: 100%; background-color: #000; }
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center; z-index: 10; }
        .visualization-legend { position: absolute; bottom: 1rem; left: 1rem; z-index: 5; }
        .legend-content { background-color: rgba(30, 30, 30, 0.9); padding: 0.8rem; border-radius: 4px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); font-size: 0.9rem; color: #e0e0e0; border: 1px solid #444; }
        .legend-badges { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
        .legend-badges .badge { padding: 0.2rem 0.4rem; font-size: 0.7rem; border-radius: 3px; color: black; }
        .separate-window-message { height: 100%; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 1rem; color: #9e9e9e; }
        
        @media (max-width: 1200px) {
          .app-layout { grid-template-columns: 1fr; }
          .visualization-container { height: 500px; }
        }
      `}</style>
    </div>
  );
}

export default App;
